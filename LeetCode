/**
     * 二维数组合并一维数组
     * @param array
     * @return
     */
    private int[] mergeArray(int[][] array){
        return mergeArray(array, 0, array.length - 1);
    }

    private int[] mergeArray(int[][] array, int l, int r){
        if(l >= r){
            return array[l];
        }

        int mid = l + (r - l) / 2;
        int[] left = mergeArray(array, l, mid);
        int[] right = mergeArray(array, mid + 1, r);
        return mergeArray(left, right);
    }

    private int[] mergeArray(int[] a1, int[] a2){
        int l1;
        if(a1 == null || (l1 = a1.length) == 0){
            return a2;
        }

        int l2;
        if(a2 == null || (l2 = a2.length) == 0){
            return a1;
        }

        int[] result = new int[l1 + l2];
        int i = 0, j = 0, k = 0;
        while (i < l1 && j < l2){
            if(a1[i] < a2[j]){
                result[k++] = a1[i++];
            }else {
                result[k++] = a2[j++];
            }
        }

        while (i < l1){
            result[k++] = a1[i++];
        }
        while ((j < l2)){
            result[k++] = a2[j++];
        }
        return result;
    }

    /**
     * 单链表指定位置反转
     * @param head
     * @param left
     * @param right
     * @return
     */
    private Node reverseBetween(Node head, int left, int right) {
        if(head == null || right < left){
            return null;
        }

        Node tmp = new Node(-1);
        tmp.next = head;

        Node pre = tmp;
        for(int i = 0;i < left - 1;i++){
            pre = pre.next;
        }

        Node next;
        Node cur = pre.next;
        for(int i = 0;i < right - left;i++){
            next = cur.next;
            cur.next = next.next;
            next.next = pre.next;
            pre.next = next;
        }
        return tmp.next;
    }

    /**
     * 双调数组查找指定的值
     * @param arr 双调数组
     * @param tar 目标值
     * @return 目标值下标
     */
    private int rank(int[] arr, int tar){
        int low = 0;
        int high = arr.length - 1;
        int index = -1;

        while (low <= high){
            int mid = low + (high - low) / 2;
            if(arr[mid] == tar){
                return mid;
            }

            //升序
            if(arr[mid] > arr[mid - 1]){
                if(arr[mid] > tar){
                    index = binaryUp(arr, tar, low, mid);
                    if(index != -1){
                        return index;
                    }
                }
                low = mid + 1;
            }

            //降序
            if(arr[mid] < arr[mid - 1]){
                if(arr[mid] > tar){
                    index = binaryDown(arr, tar, mid, high);
                    if(index != -1){
                        return index;
                    }
                }
                high = mid - 1;
            }
        }
        return -1;
    }

    private int binaryUp(int[] arr, int tar, int low, int high){
        while (low <= high){
            int mid = low + (high - low) / 2;
            if(arr[mid] < tar){
                low = mid + 1;
            }else if(arr[mid] > tar){
                high = mid - 1;
            }else {
                return mid;
            }
        }
        return -1;
    }

    private int binaryDown(int[] arr, int tar, int low, int high){
        while (low <= high){
            int mid = low + (high - low) / 2;
            if(arr[mid] < tar){
                high = mid - 1;
            }else if(arr[mid] > tar){
                low = mid + 1;
            }else {
                return mid;
            }
        }
        return -1;
    }

    /**
     * 数组的所有排列组合
     */
    private List<List<Integer>> combine(int[] arr){
        List<List<Integer>> result = new ArrayList<>();
        int len;
        if(arr == null || (len = arr.length) == 0){
            return result;
        }

        combine(len, arr, 0, result);
        return result;
    }

    private void combine(int n, int[] arr, int index, List<List<Integer>> result){
        if(index == n){
            result.add(new ArrayList<Integer>(){{
                for (int i: arr){
                    add(i);
                }
            }});
            return;
        }
        for (int i = index;i < n;i++){
            if(i != index){
                swap(arr, i, index);
            }
            combine(n, arr, index + 1, result);
            if(i != index){
                swap(arr, i, index);
            }
        }
    }

    /**
     * 剑指-31
     */
    private boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed.length != popped.length){
            return false;
        }
        
        Deque<Integer> deque = new LinkedList<>();
        int i = 0;
        for (int num : pushed) {
            //入栈每个元素
            deque.push(num);
            //模拟栈的栈顶数据和出栈数据一致，则出栈并判断出栈数组的下一个元素
            while (!deque.isEmpty() && deque.peek().equals(popped[i])){
                deque.pop();
                i++;
            }
        }
        //如果最终能匹配出栈数组，则模拟栈为空
        return deque.isEmpty();
    }

    /**
     * 剑指-30
     */
    class MinStack {
        private Deque<Integer> stack;
        private Deque<Integer> stackOther;

        public MinStack() {
            stack = new LinkedList<>();
            stackOther = new LinkedList<>();
        }

        public void push(int x) {
            stack.push(x);
            if(stackOther.isEmpty() || stackOther.peek() >= x){
                stackOther.push(x);
            }
        }

        public void pop() {
            if(stack.pop().equals(stackOther.peek())){
                stackOther.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int min() {
            return stackOther.peek();
        }
    }

    /**
     * 剑指-29
     */
    private int[] spiralOrder(int[][] matrix) {
        int l = 0, t = 0, r = matrix[0].length - 1, b = matrix.length - 1;
        int[] res = new int[(r + 1) * (b + 1)];
        int x = 0;
        for (;;){
            //从左到右，从上到下，从右到左，从下到上依次循环，直到所有元素都被遍历
            for (int i = l;i <= r;i++){
                res[x++] = matrix[t][i];
            }
            //从左到右遍历完一次，相当于完成了一行，故进行++t操作，如果已经超过了底部，则跳出循环
            if(++t > b){
                break;
            }

            for (int i = t;i <= b;i++){
                res[x++] = matrix[i][r];
            }
            if(--r < l){
                break;
            }

            for (int i = r;i >= l;i--){
                res[x++] = matrix[b][i];
            }
            if(--b < t){
                break;
            }

            for (int i = b;i >= t;i--){
                res[x++] = matrix[i][l];
            }
            if(++l > r){
                break;
            }
        }
        return res;
    }

    /**
     * 剑指-28
     */
    private boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        return recur(root.left, root.right);
    }

    private boolean recur(TreeNode a, TreeNode b){
        if(a == null && b == null){
            return true;
        }
        if(a == null || b == null || a.value != b.value){
            return false;
        }
        return recur(a.left, b.right) && recur(a.right, b.left);
    }

    /**
     * 剑指-27
     */
    private TreeNode mirrorTree(TreeNode root) {
        if(root == null){
            return null;
        }
        Deque<TreeNode> queue = new LinkedList<>();
        queue.push(root);
        while (queue.size() > 0){
            TreeNode poll = queue.poll();
            TreeNode left = poll.left;
            TreeNode right = poll.right;
            if(left != null){
                queue.push(left);
            }
            if(right != null){
                queue.push(right);
            }
            poll.right = left;
            poll.left = right;
        }
        return root;
    }

    /**
     * 剑指-26
     */
    private boolean isSubStructure(TreeNode A, TreeNode B) {
        //A从根节点计算包含B，或者A的左右子树包含B
        return (A != null && B != null) && (help(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }

    private boolean help(TreeNode A, TreeNode B){
        if(B == null){
            return true;
        }
        if(A == null || A.value != B.value){
            return false;
        }
        //递归逐个判断元素是否相等
        return help(A.left, B.left) && help(A.right, B.right);
    }

    /**
     * 剑指-25
     */
    private Node mergeTwoLists(Node l1, Node l2) {
        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }

        Node head = new Node(-1);
        Node newHead = head;
        while(l1 != null && l2 != null){
            if(l1.value > l2.value){
                head.next = l2;
                l2 = l2.next;
            }else {
                head.next = l1;
                l1 = l1.next;
            }
            head = head.next;
        }

        head.next = l1 == null ? l2 : l1;

        return newHead.next;
    }

    /**
     * 剑指-22(递归)
     */
    private Node reverseList(Node head) {
        if(head.next == null){
            return head;
        }

        Node tail = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return tail;
    }

    /**
     * 剑指-22
     */
    private Node getKthFromEnd(Node head, int k) {
        Node first = head;
        Node second = first;
        while (k > 0){
            second = second.next;
            k--;
        }

        while (second != null){
            second = second.next;
            first = first.next;
        }
        return first;
    }


    /**
     * 剑指-21
     */
    private int[] exchange(int[] nums) {
        int len;
        if(nums == null || (len = nums.length) == 0){
            return nums;
        }
        int left = 0, right = len - 1;

        while(left < right){
            while((nums[left] & 1) == 1 && left < right){
                left++;
            }
            while((nums[right] & 1) == 0 && left < right){
                right--;
            }
            swap(nums, left, right);
        }
        return nums;
    }

    private void swap(int[] nums, int from, int to){
        int tmp = nums[from];
        nums[from] = nums[to];
        nums[to] = tmp;
    }

    /**
     * 剑指-18
     */
    private Node deleteNode(Node head, int val) {
        if(head == null){
            return null;
        }
        if(head.value == val){
            return head.next;
        }

        Node cur = head;
        Node next = head.next;
        while (next != null){
            if(next.value == val){
                head.next = next.next;
                break;
            }
            head = head.next;
            next = next.next;
        }
        return cur;
    }

    /**
     * 剑指-17(end=10的n次方-1)
     */
    private int[] printNumbers(int n) {
        int end = (int)Math.pow(10, n) - 1;
        int[] arr = new int[end];
        for (int i = 0;i < end;i++){
            arr[i] = i + 1;
        }
        return arr;
    }

    /**
     * 剑指-16
     */
    private double myPow(double x, int n) {
        if(x == 0){
            return 0;
        }
        double res = 1.0;
        long b = n;
        if(b < 0){
            b = -b;
            x = 1 / x;
        }

        while(b > 0){
            if((b & 1) == 1){
                res *= x;
            }
            x *= x;
            b = b >> 1;
        }
        return res;
    }

    /**
     * 剑指-12
     */
    private boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        char[] words = word.toCharArray();
        for (int i = 0;i < m;i++){
            for (int j = 0;j < n;j++){
                if(dfs(board, words, i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, char[] words, int m, int n, int k){
        if(m < 0 || m >= board.length || n < 0 || n >= board[0].length || words[k] != board[m][n]){
            return false;
        }

        if(k == words.length - 1){
            return true;
        }
        board[m][n] = ' ';
        boolean res = dfs(board, words, m + 1, n, k + 1) || dfs(board, words, m - 1, n, k + 1) ||
                dfs(board, words, m, n + 1, k + 1) || dfs(board, words, m, n - 1, k + 1);
        board[m][n] = words[k];
        return res;
    }

    /**
     * 剑指-15
     */
    private int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            if((n & 1) > 0){
                count++;
            }
            n = n >> 1;
        }
        return count;
    }

    /**
     * 剑指-13
     */
    private int movingCount(int m, int n, int k) {
        int[] arr = new int[]{0, 0, 0, 0};
        boolean[][] dp = new boolean[m][n];
        int res = 0;

        Queue<int[]> queue = new LinkedList<>();
        queue.add(arr);
        while (!queue.isEmpty()){
            int[] poll = queue.poll();
            int i = poll[0],j = poll[1], si = poll[2], sj = poll[3];
            if(i >= m || j >= n || si + sj > k || dp[i][j]){
                continue;
            }

            dp[i][j] = true;
            res++;
            queue.add(new int[]{i + 1, j, getSum(i + 1), sj});
            queue.add(new int[]{i, j + 1, si, getSum(j + 1)});
        }

        return res;
    }

    private int getSum(int i){
        int res = 0;
        while (i > 0){
            res += i % 10;
            i /= 10;
        }
        return res;
    }

    /**
     * 剑指-11
     */
    private int minArray(int[] numbers) {
        int len;
        if(numbers == null || (len = numbers.length) == 0){
            return -1;
        }

        int low = 0;
        int high = len - 1;
        while (low < high){
            int mid = low + (high - low) / 2;
            if(numbers[mid] < numbers[high]){
                high = mid;
            }else if(numbers[mid] > numbers[high]){
                low = mid + 1;
            }else {
                high--;
            }
        }
        return numbers[low];
    }

    /**
     * 剑指-06
     */
    private int[] reversePrint(Node head) {
        if(head == null){
            return new int[]{};
        }

        Deque<Node> queue = new LinkedList<>();
        while(head != null){
            queue.push(head);
            head = head.next;
        }

        int len = queue.size();
        int[] arr = new int[len];
        for(int i = 0;i < len;i++){
            arr[i] = queue.pop().value;
        }
        return arr;
    }

    /**
     * 剑指-05
     */
    private String replaceSpace(String s) {
        if(s == null || "".equals(s)){
            return s;
        }
        int len = s.length();
        int size = 0;
        char[] newArr = new char[len * 3];
        for(int i = 0;i < len;i++){
            char c = s.charAt(i);
            if(' ' == c){
                newArr[size++] = '%';
                newArr[size++] = '2';
                newArr[size++] = '0';
            }else{
                newArr[size++] = c;
            }
        }
        return new String(newArr, 0, size);
    }

    /**
     * 剑指-04
     */
    private boolean findNumberIn2DArray(int[][] matrix, int target) {
        int len;
        if(matrix == null || (len = matrix.length) == 0){
            return false;
        }

        for(int i = 0;i < len;i++){
            int l;
            if(matrix[i] == null || (l = matrix[i].length) == 0){
                return false;
            }

            for(int j = 0;j < l;j++){
                if(matrix[i][j] ==  target){
                    return true;
                }
                if(matrix[i][j] > target){
                    break;
                }
            }
        }
        return false;
    }

    private int[][] bag0_1(int[] w, int[] v, int c){
        int m = w.length;

        int[][] dp = new int[m][c + 1];
        for (int j = 1; j <= c; j++){
            if(j < w[0]){
                dp[0][j] = 0;
            }else {
                dp[0][j] = v[0];
            }
        }

        for (int i = 1;i < m;i++){
            for (int j = 1;j <= c;j++){
                if(j < w[i]){
                    dp[i][j] = dp[i - 1][j];
                }else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
                }
            }
        }
        return dp;
    }

    /**
     * 两个栈实现队列，剑指-09
     * @param <E>
     */
    private static class MyQueue<E>{
        private Deque<E> first = new LinkedList<>();

        private Deque<E> second = new LinkedList<>();

        public boolean add(E e){
            first.push(e);
            return true;
        }

        public E get(){
            if(second.isEmpty()){
                while (!first.isEmpty()){
                    second.push(first.pop());
                }
            }
            return second.pop();
        }
    }

    /**
     * 二叉树之形打印
     * @param head 头结点
     * @return
     */
    private ArrayList<ArrayList<Integer>> binaryZhi(TreeNode head){
        if(head == null){
            return new ArrayList<>();
        }

        boolean b = false;
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        Deque<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        while (!queue.isEmpty()){
            int size = queue.size();

            ArrayList<Integer> list = new ArrayList<>(size);

            for (int i = 0;i < size;i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
                if(!b){
                    list.add(node.value);
                }else {
                    list.add(0, node.value);
                }

            }
            b = !b;
            result.add(list);
        }

        return result;
    }

    /**
     * 是否为完全二叉树
     * @param root
     * @return
     */
    private boolean isCompleteBinary(TreeNode root){
        if(root == null){
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            //从左到右广度优先遍历，找到第一个左孩子或右孩子为空的节点
            if(node.left != null){
                queue.add(node.left);
            }else {
                //左孩子为空时，判断一下右孩子，fail-fast
                if(node.right != null){
                    return false;
                }else {
                    break;
                }
            }
            if(node.right != null){
                queue.add(node.right);
            }else {
                break;
            }
        }

        //一旦出现了左孩子或右孩子为空的节点，其后续的节点必须为子节点
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node.left != null || node.right != null){
                return false;
            }
        }
        return true;
    }

    /**
     * 是否为平衡二叉树
     * @param root
     * @return
     */
    private boolean isBalanceBinary(TreeNode root){
        if(root == null){
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int size;
        while (!queue.isEmpty()){
            size = queue.size();
            //将一行的元素全部遍历，其子节点放入队列
            for (int i = 0;i < size;i++){
                TreeNode node = queue.poll();
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }
            //如果下层节点个数不是上层的二倍，说明上层存在叶子节点
            if(size << 1 > queue.size()){
                break;
            }
        }

        //存在叶子节点的下一层如果存在子节点，说明高度差至少为2，说明不是平衡二叉树
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node.left != null || node.right != null){
                return false;
            }
        }
        return true;
    }

    /**
     * 搜索插入位置-35
     * @param nums
     * @param target
     * @return
     */
    private int searchInsert(int[] nums, int target) {
        int len;
        if(nums == null || (len=  nums.length) == 0){
            return 0;
        }

        int l = 0;
        int r = len - 1;
        int ans = len;
        while (l <= r){
            int mid = (r + l) / 2;
            if(nums[mid] >= target){
                ans = mid;
                r = mid - 1;
            }else {
                l = mid + 1;
            }
        }
        return ans;
    }

    /**
     * 排序数组中查找出现的第一个位置和最后一个位置
     * @param nums 数组
     * @param target 目标数
     * @return 出现位置
     */
    private int[] searchRange(int[] nums, int target){
        int[] arr = {-1, -1};
        int len;
        if(nums == null || (len = nums.length) == 0){
            return arr;
        }

        return searchRange(nums, target, 0, len - 1);
    }

    private int[] searchRange(int[] nums, int target, int start, int end){
        if(start > end){
            return new int[]{-1, -1};
        }
        int mid = (start + end) / 2;
        if(nums[mid] < target){
            return searchRange(nums, target, mid + 1, end);
        }else if(nums[mid] > target){
            return searchRange(nums, target, start, mid - 1);
        }else {
            int l = mid;
            int r = mid;
            while (l >= start && nums[l] == target){
                l--;
            }
            while (r <= end && nums[r] == target){
                r++;
            }
            return new int[]{l + 1, r - 1};
        }
    }

    private int search(int[] nums, int target){
        int len;
        if(nums == null || (len = nums.length) == 0){
            return -1;
        }

        if (len == 1) {
            return nums[0] == target ? 0 : -1;
        }

        int first = nums[0];
        int i = 0;
        while (i + 1 < len){
            if(nums[i] > nums[i + 1]){
                break;
            }
            i++;
        }

        if(target < first){
            for (int j = i + 1;j < len;j++){
                if(nums[j] == target){
                    return j;
                }
            }
        }else {
            for (int j = 0;j <= i;j++){
                if(nums[j] == target){
                    return j;
                }
            }
        }
        return -1;
    }

    /**
     * 字符串查找
     * @param s1 s1
     * @param s2 s2
     * @return 起始位置
     */
    private int indexOf(String s1, String s2){
        int cur = 0;
        char first = s2.charAt(0);
        int max = s1.length() - s2.length();
        while (cur < s1.length()){
            while(cur <= max && s1.charAt(cur) != first){
                cur++;
            }
            int j = cur;
            int end = cur + s2.length();
            for (int k = 0;k < s2.length() && s1.charAt(cur) == s2.charAt(k);k++){
                cur++;
            }
            if(cur <= s1.length() && cur == end){
                return j;
            }else {
                cur++;
            }
        }
        return -1;
    }

    /**
     * 删除数组中的指定元素
     * @param arr 数组
     * @return 删除后数组中元素的个数
     */
    private int removeElement(int[] arr, int val){
        int len;
        if(arr == null || (len = arr.length) == 0){
            return 0;
        }
        int i = 0;
        for (int j = 0;j < len;j++){
            if(arr[j] != val){
                arr[i] = arr[j];
                i++;
            }
        }
        return i;
    }

    /**
     * 删除排序数组中的重复项
     * @param arr 数组
     * @return 不重复元素个数
     */
    private int longestDiffNum(int[] arr){
        int len;
        if(arr == null || (len = arr.length) == 0){
            return 0;
        }

        int max = 0;
        for (int i = 0;i < len;i++){
            if(arr[max] < arr[i]){
                max++;
                arr[max] = arr[i];
            }
        }
        return max + 1;
    }

    /**
     * 堆排序
     * @param arr 排序数组
     */
    private void heapSort(int[] arr){
        int len;
        if(arr == null || (len = arr.length) == 0){
            return;
        }
        int start = len / 2 - 1;
        for (int i = start;i >= 0;i--){
            adjustHeap(arr, i, len);
        }

        for (int i = len - 1;i > 0; i--){
            swapArr(arr, 0, i);
            adjustHeap(arr, 0, i);
        }
    }

    private void adjustHeap(int[] arr, int index, int len){
        int tem = arr[index];
        for (int i = 2 * index + 1;i <len;i = 2 * i + 1){
            if((i + 1) < len && arr[i] < arr[i + 1]){
                i++;
            }

            if(arr[i] > tem){
                swapArr(arr, i, index);
                index = i;
            }else {
                break;
            }
        }
    }

    private void swapArr(int[] arr, int from, int to){
        int tem = arr[from];
        arr[from] = arr[to];
        arr[to] = tem;
    }

    /**
     * 链表每两个交换位置
     * @param head 头结点
     * @return 交换后的链表
     */
    private Node swapPairs(Node head){
        if(head == null || head.next == null){
            return head;
        }

        Node tem = new Node(-1, head);
        Node prev = tem;
        while (prev.next != null && prev.next.next != null){
            Node n1 = prev.next;
            Node n2 = prev.next.next;
            n1.next = n2.next;
            n2.next = n1;
            prev.next = n2;
            prev = n1;
        }

        return tem.next;
    }

    /**
     * 拆分数字n，求拆分的乘积最大——动态规划优化
     * @param n 拆分数字n
     * @return 最大乘积
     */
    private int integerBreakOp(int n){
        if(n < 4){
            return n - 1;
        }
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3;i <= n; i++){
            dp[i] = Math.max(Math.max(2 * (i - 2), 2 * dp[i - 2]), Math.max(3 * (i - 3), 3 * dp[i - 3]));
        }
        return dp[n];
    }

    /**
     * 拆分数字n，求拆分的乘积最大——动态规划
     * @param n 拆分数字n
     * @return 最大乘积
     */
    private int integerBreak(int n){
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 0;
        int max = 0;
        for (int i = 2;i <= n; i++){
            for (int j = 1;j < i; j++){
                max = Math.max(Math.max(j * (i - j), j * dp[i - j]), dp[i]);
                dp[i] = max;
            }
        }
        return max;
    }

    private List<String> bracketCombinations(int n){
        if(n <= 0){
            return list;
        }
        bracketCombinationsBacktrace("", 0, 0, n);
        return list;
    }

    /**
     * n对有效括号——递归
     * @param sb StringBuilder
     * @param left 左括号个数
     * @param right 右括号个数
     * @param n 括号对数
     */
    private void bracketCombinationsBacktrace(String sb, int left, int right, int n){
        if(left > n || right > left){
            return;
        }
        if(left == n && right == n){
            list.add(sb);
            return;
        }

        bracketCombinationsBacktrace(sb + '(', left + 1, right, n);
        bracketCombinationsBacktrace(sb + ')', left, right + 1, n);
    }

    /**
     * n对有效括号——回溯
     * @param sb StringBuilder
     * @param left 左括号个数
     * @param right 右括号个数
     * @param n 括号对数
     */
    private void bracketCombinationsBacktrace(StringBuilder sb, int left, int right, int n){
        if(sb.length() == n * 2){
            list.add(sb.toString());
            return;
        }
        //左括号数量小于n，可以继续放左括号
        if(left < n){
            sb.append('(');
            bracketCombinationsBacktrace(sb, left + 1, right, n);
            sb.deleteCharAt(sb.length() - 1);
        }

        //右括号数量小于左括号数量，可以继续放右括号
        if(right < left){
            sb.append(')');
            bracketCombinationsBacktrace(sb, left, right + 1, n);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    /**
     * 删除链表倒数第n个节点——双指针
     * @param head 链表头结点
     * @param n 链表倒数第n个节点
     * @return 删除后的链表
     */
    private Node removeFromEndWithDoublePointer(Node head, int n){
        if(head == null){
            return null;
        }
        Node tem = new Node(-1, head);
        Node left = tem;
        Node right = head;
        for (int i = 0;i < n; i++){
            right = right.next;
        }
        while (right != null){
            right = right.next;
            left = left.next;
        }

        Node cur = left.next;
        left.next = left.next.next;
        cur.next = null;
        return tem.next;
    }

    /**
     * 删除链表倒数第n个节点——计算长度遍历
     * @param head 链表头结点
     * @param n 链表倒数第n个节点
     * @return 删除后的链表
     */
    private Node removeFromEnd(Node head, int n){
        int len = 0;
        Node h = head;
        while (h != null){
            h = h.next;
            len++;
        }

        if(len == n){
            return head.next;
        }

        Node prev = head;
        for (int i = 1; i < len - n; i++){
            prev = prev.next;
        }

        Node next = prev.next;
        prev.next = prev.next.next;
        next.next = null;
        return head;
    }

    private Map<Character, String> phoneMap = new HashMap<Character, String>() {{
        //key使用字符型，因为下面的charAt方法返回的就是char，不需要额外的类型转换
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};

    private List<String> letterCombinations(String str){
        if(str == null || str.length() == 0){
            return list;
        }
        return letterCombinationsBacktrace(str, 0, new StringBuilder());
    }

    private List<String> letterCombinationsBacktrace(String str, int index, StringBuilder sb){
        //每次递归index++，当index=字符串长度时，表示本轮已经匹配完毕，已为各个数字取了一个字符
        if(index == str.length()){
            list.add(sb.toString());
        }else {
            String letters = phoneMap.get(str.charAt(index));
            for (int i = 0;i < letters.length();i++){
                sb.append(letters.charAt(i));
                letterCombinationsBacktrace(str, index + 1, sb);
                //本轮递归完毕后，需要回溯退回一个
                sb.deleteCharAt(sb.length() - 1);
            }
        }
        return list;
    }

    /**
     * 最长公共前缀——循环纵向比较
     * @param strArr 字符串数据
     * @return 最长公共前缀
     */
    private String longestCommonPrefix(String[] strArr){
        int len;
        if(strArr == null || (len = strArr.length) == 0){
            return "";
        }

        String s = strArr[0];
        for (int i = 0;i < s.length(); i++){
            for (int j = 1;j < len; j++){
                String o = strArr[j];
                //最短的字符串已经遍历完毕或者出现不一样的字符
                if(o.length() <= i || s.charAt(i) != o.charAt(i)){
                    return s.substring(0, i);
                }
            }
        }
        return s;
    }

    /**
     * 最长公共前缀——二分查找
     * @param strArr 字符串数据
     * @return 最长公共前缀
     */
    private String longestCommonPrefixBinary(String[] strArr){
        int len;
        if(strArr == null || (len = strArr.length) == 0){
            return "";
        }
        return longestCommonPrefixBinary(strArr, 0, len - 1);
    }

    private String longestCommonPrefixBinary(String[] strArr, int start, int end){
        if(start == end){
            return strArr[start];
        }
        int mid = (end - start) / 2 + start;
        String leftCommon = longestCommonPrefixBinary(strArr, start, mid);
        String rightCommon = longestCommonPrefixBinary(strArr, mid + 1, end);
        return commonPrefix(leftCommon, rightCommon);
    }

    private String commonPrefix(String s1, String s2){
        int len = Math.min(s1.length(), s2.length());
        for (int i = 0;i < len; i++){
            if(s1.charAt(i) != s2.charAt(i)){
                return s1.substring(0, i);
            }
        }
        return s1.substring(0, len);
    }

    /**
     * 最大容量
     * @param arr 数据
     * @return 最大容量
     */
    private int maxArea(int[] arr){
        int len;
        if(arr == null || (len = arr.length) == 0){
            return 0;
        }
        int left = 0;
        int right = len - 1;
        int max = 0;
        while (left < right){
            int high = Math.min(arr[right], arr[left]);
            int area = (right - left) * high;
            max = Math.max(area, max);
            if(arr[right] > arr[left]){
                left++;
            }else {
                right--;
            }
        }
        return max;
    }

    /**
     * 是否为回文数。对原始数据不断除10以截取一位，判断截取的部分和剩余部分是否相等，如num=1221变成num=12，再和newNum=12相比较
     * @param num 数字
     * @return 是否为回文数
     */
    private boolean isPalindrome(int num){
        if(num == 0){
            return true;
        }
        if(num < 0 || num % 10 == 0){
            return false;
        }

        int newNum = 0;
        //num每次除以10减少一位，当newNum大于等于num时，表示num已经被截取了一半
        while (newNum < num){
            newNum = newNum * 10 + num % 10;
            num /= 10;
        }

        //如num初始为12321，循环后，num=12，newNum=123
        return newNum == num || newNum / 10 == num;
    }

    /**
     * 最长回文子串——中心扩散
     * @param s 字符串
     * @return 最长回文子串
     */
    private String longestPalindromeCenterSpread(String s) {
        if(s == null){
            return null;
        }
        int len;
        if((len = s.length()) <= 1){
            return s;
        }
        int[] pos = new int[]{0, 1};
        for (int i = 0;i < len - 1;i++){
            //中间单个回文
            int[] odd = findPosition(s, i - 1, i + 1);
            //中间两个字符回文，即两个字符相等
            int[] event = findPosition(s, i, i + 1);
            int[] longer = odd[1] - odd[0] > event[1] - event[0] ? odd : event;
            pos = longer[1] - longer[0] > pos[1] - pos[0] ? longer : pos;
        }

        return s.substring(pos[0], pos[1]);
    }

    private int[] findPosition(String s, int left, int right){
        int len = s.length();
        while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)){
            left--;
            right++;
        }
        //left + 1是因为先判断条件，然后做left--操作，下一次循环可能不满足，所以要加回来。而String的字符串接口是左闭右开的，所以right不用操作
        return new int[]{left + 1, right};
    }

    /**
     * 最长回文子串——动态规划
     * @param s 字符串
     * @return 最长回文子串
     */
    private String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int begin = 0;
        int max = 1;
        int len;

        for(int j = 0;j < n;j++){
            for (int i = 0;i <= j; i++){
                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);
                len = j - i + 1;
                if(dp[i][j] && max < len){
                    max = len;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + max);
    }

    private int coinChange(int[] coins, int amount){
        int top = amount + 1;
        int[] dp = new int[top];
        //初始化数组中每个元素为一个不可能的较大值（实际需要硬币的个数肯定不会超过amount），如果数组该位置的值大于amount，表示此处不能按照给定硬币面额拼凑
        Arrays.fill(dp, top);
        dp[0] = 0;
        for (int i = 1;i <= amount;i++){
            for (int j = 0;j < coins.length;j++){
                //硬币面额小于等于对应的拼凑金额时，才会进行计算
                if(coins[j] <= i){
                    //和上面的初始化数组对应，如果dp[i - coins[j]]不能被拼凑出来，那么+1后肯定不会小于dp[i]
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == top ? -1 : dp[amount];
    }

    /**
     * 右侧视图广度优先遍历
     * @param root 根节点
     */
    private void rightViewScope(TreeNode root){
        if(root == null){
            return;
        }

        Map<Integer, Integer> map = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        Queue<Integer> depthQueue = new LinkedList<>();
        int maxDepth = -1;
        queue.add(root);
        depthQueue.add(0);
        while (!queue.isEmpty()){
            TreeNode poll = queue.poll();
            Integer depth = depthQueue.remove();
            if(poll != null){
                maxDepth = Math.max(maxDepth, depth);

                if(!map.containsKey(depth)){
                    map.put(depth, poll.value);
                }

                depth++;
                queue.add(poll.right);
                depthQueue.add(depth);

                queue.add(poll.left);
                depthQueue.add(depth);
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i <= maxDepth; i++) {
            list.add(map.get(i));
        }
        list.forEach(System.out::println);
    }

    /**
     * 右侧视图深度优先遍历
     * @param root 根节点
     */
    private void rightViewDepth(TreeNode root){
        if(root == null){
            return;
        }
        Map<Integer, Integer> map = new HashMap<>();
        Stack<TreeNode> stack = new Stack<>();
        Stack<Integer> depthStack = new Stack<>();
        int maxDepth = -1;

        stack.push(root);
        depthStack.push(0);
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            Integer depth = depthStack.pop();
            if(pop != null){
                maxDepth = Math.max(depth, maxDepth);

                if(!map.containsKey(depth)){
                    map.put(depth, pop.value);
                }

                depth++;
                stack.push(pop.left);
                depthStack.push(depth);

                stack.push(pop.right);
                depthStack.push(depth);
            }
        }

        List<Integer> list = new ArrayList<>();
        for (int i = 0; i <= maxDepth; i++) {
            list.add(map.get(i));
        }
        list.forEach(System.out::println);
    }

    /**
     * 通过hash表递归实现斐波那契数列
     * @param n 数列长度
     * @return 第n个数列中的值
     */
    private int recurseHash(int n){
        if(n < 2){
            return n;
        }

        Integer v;
        if((v= map.get(n)) != null){
            return v;
        }else {
            v = recurseHash(n - 1) + recurseHash(n - 2);
            map.put(n, v);
            return v;
        }
    }

    /**
     * 使用长度为2的数组，通过动态规划实现斐波那契数列
     * @param n 数列长度
     * @return 第n个数列中的值
     */
    private int dp(int n){
        if(n < 2){
            return n;
        }
        int[] dp = {0, 1};
        boolean b = true;
        int result = 0;
        for (int i = 2;i <= n;i++){
            result = dp[0] + dp[1];
            if(b){
                dp[0] = result;
            }else {
                dp[1] = result;
            }
            b = !b;
        }

        return result;
    }

    /**
     * 最多走法
     * @param m 行
     * @param n 列
     * @return 最多走法
     */
    private int mostWays(int m, int n){
        if(m == 1 || n == 1){
            return 1;
        }
        int[][] arr = new int[m][n];
        for (int i = 0;i < m;i++){
            for (int j = 0;j < n;j++){
                if(i == 0 || j == 0){
                    arr[i][j] = 1;
                }else {
                    arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
                }
            }
        }
        return arr[m - 1][n - 1];
    }

    private Node getIntersectionNode(Node head1, Node head2) {

        if (head1 == null || head2 == null) {
            return null;
        }
        Node node1 = head1, node2 = head2;
        //当两个链表没有交叉时，最终会遍历完对应的链表，null==null为true
        while (node1 != node2) {
            node1 = node1 == null ? head2 : node1.next;
            node2 = node2 == null ? head1 : node2.next;
        }
        return node1;
    }


    /**
     * 最长公共子串（循环中初始化）
     * @param s1 字符串1
     * @param s2 字符串2
     * @return 最长公共子串长度
     */
    private int maxCommonStringInitInLoop(String s1, String s2){
        if(StringUtils.isEmpty(s1) || StringUtils.isEmpty(s2)){
            return 0;
        }
        int len1 = s1.length();
        int len2 = s2.length();
        int[][] arr = new int[len1][len2];

        int max = 0;
        for (int i = 0;i < len1; i++){
            for (int j = 0;j < len2;j++){
                //只需要初始化二维数组上和左两侧即可
                if(s1.charAt(i) == s2.charAt(j)){
                    if(i == 0 || j == 0){
                        arr[i][j] = 1;
                    }else {
                        arr[i][j] = arr[i - 1][j - 1] + 1;
                    }
                    max = Math.max(max, arr[i][j]);
                }
            }
        }
        return max;
    }

    private int maxCommonString(String s1, String s2){
        if(StringUtils.isEmpty(s1) || StringUtils.isEmpty(s2)){
            return 0;
        }
        int len1 = s1.length();
        int len2 = s2.length();
        int[][] arr = new int[len1][len2];
        for (int i = 0;i < len1; i++){
            for (int j = 0;j<len2;j++){
                if(s1.charAt(i) == s2.charAt(j)){
                    arr[i][j] = 1;
                }else {
                    arr[i][j] = 0;
                }
            }
        }

        int max = 0;
        for (int i = 1;i < len1; i++){
            for (int j = 1;j < len2;j++){
                if(s1.charAt(i) == s2.charAt(j)){
                    arr[i][j] = arr[i - 1][j - 1] + 1;
                    max = Math.max(max, arr[i][j]);
                }
            }
        }
        return max;
    }

    /**
     * 输入: [10,9,2,5,3,7,101,18]
     * 输出: 4
     * 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
     * @return 最长的上升子序列
     */
    private int longestSeq(int[] array){
        int length;
        if(array == null || (length = array.length) == 0){
            return 0;
        }

        int[] arr = new int[length];
        Arrays.fill(arr, 1);

        int max = 1;

        for (int i = 1; i < length; i++) {
            for (int j = 0; j < i; j++) {
                if(array[i] > array[j] && arr[j] + 1 > arr[i]){
                    arr[i] = arr[j] + 1;
                }
            }
            max = Math.max(arr[i], max);
        }
        return max;
    }

    /**
     * 最长子串
     * @param s 字符串
     * @return 最长子串长度
     */
    private int longestChar(String s){
        Set<Character> set = new HashSet<>();

        int max = 0;
        int left = 0;
        for (int i = 0;i < s.length(); i++) {
            //除第一次循环外，每次移除最左边的元素（每次循环表示有重复的元素，否则下面的while循环会一直进行下去）
            if(i > 0){
                set.remove(s.charAt(i - 1));
            }

            //一直向右移动，直到出现重复元素或循环完毕
            while (left < s.length() && !set.contains(s.charAt(left))){
                set.add(s.charAt(left));
                left++;
            }

            //每循环一次都记录一下最大长度
            max = Math.max(max, left - i);
        }
        return max;
    }

    private int binarySearch(int[] array, int low, int high, int aim){
        if(low > high){
            return -1;
        }

        int mid = (low + high) / 2;
        if(aim == array[mid]){
            return mid;
        }
        if(array[mid] < aim){
            return binarySearch(array, mid + 1, high, aim);
        }else {
            return binarySearch(array, low, mid - 1, aim);
        }
    }

    private Node oddEven(Node head){
        if(head == null || head.next == null){
            return head;
        }

        //奇数头结点
        Node odd = head;
        //偶数头结点
        Node event = head.next;

        Node node = head.next;
        while (node != null && node.next != null){
            //奇数节点指针指向下一个节点的下一个节点，进而生成一个奇数链表
            head.next = head.next.next;
            //因为上面的指针变化，其实是在原链表上移动两位
            head = head.next;

            //偶数节点指针指向下一个节点的下一个节点，进而生成一个偶数链表
            node.next = node.next.next;
            node = node.next;
        }
        //循环之后，原来的head节点已经指向奇数链表的尾节点，此时连接两个链表
        head.next = event;
        return odd;
    }

    private int age(int index){
        if(index == 0){
            return 10;
        }
        return age(index - 1) + 2;
    }

    private int next(int index){
        if(index == 1){
            return 0;
        }
        if(index == 2){
            return 1;
        }
        return next(index -1) + next(index - 2);
    }

    private void print(Node head){
        while (head != null){
            System.out.println(head.value);
            head = head.next;
        }
    }

    private void printRevert(Node head){
        if(head.next != null){
            printRevert(head.next);
        }
        System.out.println(head.value);
    }

    private Node sortLink(Node head){
        if(head == null){
            return null;
        }
        //创建临时节点，指向头结点，用于排序好之后，返回头结点（临时节点的下一个节点就是排序后链表的头结点）
        Node temp = new Node(-1);
        temp.next = head;

        //作为当前要判断和移动的节点，初始值为第二个节点
        Node curr = head.next;
        //每次移动之后，当前节点的前部分已经排序好，作为排序好链表的最后节点
        Node last = head;
        while (curr != null){
            if(last.value <= curr.value){
                last = last.next;
            }else {
                //作为排序好链表的头结点的前一个节点，用于遍历排序好的链表，判断后续节点应该插入的位置
                Node prev = temp;
                //prev指向应插入位置的前一个节点
                while (prev.next.value <= curr.value){
                    prev = prev.next;
                }

                //插入节点，排序好的链表的最后一个节点指向要排序节点的下一个节点
                last.next = curr.next;
                //插入要排序的节点
                curr.next = prev.next;
                prev.next = curr;
            }
            curr = last.next;
        }

        return temp.next;
    }
