/**
 * 冒泡排序
 * @param array 要排序的数组
 */
private void bubbleSort(int[] array){
    if(array.length == 0){
        return;
    }
    int length = array.length;
    for (int i = 0;i < length; i++){
        for (int j = i + 1;j < length; j++){
            if(array[i] > array[j]){
                int tem = array[i];
                array[i] = array[j];
                array[j] = tem;
            }
        }
    }
}

/**
 * 快速排序
 * 选取第一个元素作为基准，从右到左开始寻找第一个比基准小的节点，并从左到右找到第一个比基准大的节点，然后交换两个节点位置
 * 当两个循环相遇时，交换相遇节点和基准节点
 * 此时经过一次循环，保证比基准小的节点都在左边，比基准大的节点都在右边，然后递归调用即可
 * @param array 要排序的数组
 */
private void quickSort(int[] array, int low, int high){
    if(low > high){
        return;
    }
    int t;
    int tem = array[low];
    int i = low;
    int j = high;
    while (i < j){
        while (tem <= array[j] && i < j){
            //从右到左循环，找到第一个比基准小的节点
            j--;
        }

        while (tem >= array[i] && i < j){
            //从左到右循环，找到第一个比基准大的节点
            i++;
        }
        //交换比基准大的节点和比基准小的节点
        if(i < j){
            t = array[i];
            array[i] = array[j];
            array[j] = t;
        }
    }
    //交换基准节点和两个循环相遇节点
    array[low] = array[i];
    array[i] = tem;
    //递归调用
    quickSort(array, low, i - 1);
    quickSort(array, i + 1, high);
}

/**
 * 链表排序
 * @param head 要排序的链表
 */
private Node sortLink(Node head){
    if(head == null){
        return null;
    }
    //创建临时节点，指向头结点，用于排序好之后，返回头结点（临时节点的下一个节点就是排序后链表的头结点）
    Node temp = new Node(-1);
    temp.next = head;

    //作为当前要判断和移动的节点，初始值为第二个节点
    Node curr = head.next;
    //每次移动之后，当前节点的前部分已经排序好，作为排序好链表的最后节点
    Node last = head;
    while (curr != null){
        if(last.value <= curr.value){
            last = last.next;
        }else {
            //作为排序好链表的头结点的前一个节点，用于遍历排序好的链表，判断后续节点应该插入的位置
            Node prev = temp;
            //prev指向应插入位置的前一个节点
            while (prev.next.value <= curr.value){
                prev = prev.next;
            }

            //插入节点，排序好的链表的最后一个节点指向要排序节点的下一个节点
            last.next = curr.next;
            //插入要排序的节点
            curr.next = prev.next;
            prev.next = curr;
        }
        curr = last.next;
    }

    return temp.next;
}

/**
     * 堆排序
     * @param arr
     */
    private void heapSort(int[] arr){
        int len;
        if(arr == null || (len = arr.length) == 0){
            return;
        }

        //第一个非叶子节点
        int start = len / 2 - 1;
        //针对每个非叶子节点进行比较交换
        for (int i = start; i >= 0; i--){
            adjustArr(arr, i, len);
        }

        //交换首尾元素，重新生成堆
        for (int i = len - 1;i > 0;i--){
            swapArr(arr, 0 , i);
            //此时的堆，除了头节点之外都已排序完毕，所以每次只需要对头节点排序即可
            adjustArr(arr, 0, i);
        }
    }

    private void adjustArr(int[] arr, int index, int len){
        //记录非叶子结点的值
        int tem = arr[index];
        //每次调整后，节点的孩子节点可能与 孩子节点的孩子节点 大小发生变化（上面的移动可能导致下面的排序失效），所以for循环的步长即为当前节点的左孩子节点（2 * index + 1）
        for (int i = 2 * index + 1;i < len; i = 2 * i + 1){
            //如果有右孩子节点，且右孩子比左孩子大，则使用右孩子与父节点比较
            if((i + 1) < len && arr[i] < arr[i + 1]){
                i++;
            }
            //比较孩子节点和父节点大小
            if(arr[i] > tem){
                //交换父子节点值
                swapArr(arr, index, i);
                //让index指向孩子节点，下次循环中，孩子节点将作为父节点
                index = i;
            }else {
                //如果堆的上层大小没有变化，则堆的下一层一定没有变化（堆的上层变化才可能导致堆的下层变化），提前跳出循环
                break;
            }
        }
    }
    
    private void swapArr(int[] arr, int from, int to){
        int tem = arr[from];
        arr[from] = arr[to];
        arr[to] = tem;
    }
