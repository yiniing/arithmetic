/**
 * 冒泡排序
 * @param array 要排序的数组
 */
private void bubbleSort(int[] array){
    if(array.length == 0){
        return;
    }
    int length = array.length;
    for (int i = 0;i < length; i++){
        for (int j = i + 1;j < length; j++){
            if(array[i] > array[j]){
                int tem = array[i];
                array[i] = array[j];
                array[j] = tem;
            }
        }
    }
}

/**
 * 快速排序
 * 选取第一个元素作为基准，从右到左开始寻找第一个比基准小的节点，并从左到右找到第一个比基准大的节点，然后交换两个节点位置
 * 当两个循环相遇时，交换相遇节点和基准节点
 * 此时经过一次循环，保证比基准小的节点都在左边，比基准大的节点都在右边，然后递归调用即可
 * @param array 要排序的数组
 */
private void quickSort(int[] array, int low, int high){
    if(low > high){
        return;
    }
    int t;
    int tem = array[low];
    int i = low;
    int j = high;
    while (i < j){
        while (tem <= array[j] && i < j){
            //从右到左循环，找到第一个比基准小的节点
            j--;
        }

        while (tem >= array[i] && i < j){
            //从左到右循环，找到第一个比基准大的节点
            i++;
        }
        //交换比基准大的节点和比基准小的节点
        if(i < j){
            t = array[i];
            array[i] = array[j];
            array[j] = t;
        }
    }
    //交换基准节点和两个循环相遇节点
    array[low] = array[i];
    array[i] = tem;
    //递归调用
    quickSort(array, low, i - 1);
    quickSort(array, i + 1, high);
}

/**
 * 链表排序
 * @param head 要排序的链表
 */
private Node sortLink(Node head){
    if(head == null){
        return null;
    }
    //创建临时节点，指向头结点，用于排序好之后，返回头结点（临时节点的下一个节点就是排序后链表的头结点）
    Node temp = new Node(-1);
    temp.next = head;

    //作为当前要判断和移动的节点，初始值为第二个节点
    Node curr = head.next;
    //每次移动之后，当前节点的前部分已经排序好，作为排序好链表的最后节点
    Node last = head;
    while (curr != null){
        if(last.value <= curr.value){
            last = last.next;
        }else {
            //作为排序好链表的头结点的前一个节点，用于遍历排序好的链表，判断后续节点应该插入的位置
            Node prev = temp;
            //prev指向应插入位置的前一个节点
            while (prev.next.value <= curr.value){
                prev = prev.next;
            }

            //插入节点，排序好的链表的最后一个节点指向要排序节点的下一个节点
            last.next = curr.next;
            //插入要排序的节点
            curr.next = prev.next;
            prev.next = curr;
        }
        curr = last.next;
    }

    return temp.next;
}
